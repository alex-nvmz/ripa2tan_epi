---
title: "Notebook"
execute: 
  warning: false
  eval: false
toc: true
toc-depth: 3
toc-expand: true
fig-width: 11
fig-asp: 0.618
# fig-height: 6.18
format:
  html:
    grid:
      body-width: 950px
    embed-resources: true
# knitr:
#   opts_chunk:
#     out.width: "100%"
---

Notebook to document RIPA2TAN analysis.

# Data processing

```{r}

library(tidyverse)
theme_set(theme_bw(base_size = 16))
library(readxl)
library(ggokabeito)
library(ggh4x)  # facet_nested

base_path <- ".."
data_path <- file.path(base_path, "data")
res_path <- file.path(base_path, "results")

# data_path <- "local_data_path"
```

## Population data

We need the yearly disease burden excel to get the yearly population.

```{r}

# Get yearly population

pop <- read_excel(
  file.path(data_path, "raw", "disease_burden_yearly.xlsx"),
  sheet = "Sheet1"
  )

pop <- pop |> 
  group_by(District, Year) |> 
  summarise(Population = mean(Population)) |> 
  ungroup() |> 
  rename(
    district=District,
    year=Year,
    population=Population
  )

pop

pop |> 
  ggplot() +
  geom_point(
    aes(x=year, y=population, color=district)
  )
```

We are missing the population of 2022, and we have disease data for that year. A linear interpolation seems appropriate.

```{r}
fit <- lm(population ~ year + district + year:district, data=pop)

newdata <- data.frame(
  district = c("Moshi", "Siha"),
  year = c(2022, 2022)
)

newdata$population <- predict(fit, newdata=newdata)
newdata <- mutate(newdata, population=round(population))
pop <- pop |> 
  bind_rows(newdata)

pop |> 
  ggplot() +
  geom_point(
    aes(x=year, y=population, color=district)
  ) +
  geom_smooth(
    aes(x=year, y=population, color=district), method = "lm", se = FALSE
  )
```

## Environmental data

The environmental data is disggregated in different files.

### PM2.5

For PM2.5, originally we received the file 'avgpm25_monthly.csv'. After that, we received 'avg_pm25_monthly_siha_np.csv', with the values for Siha calculated without considering the National Park area (this is better). We will substitute the values of the second file onto the first one.


```{r}

pm2p5 <- read_csv(
  file.path(data_path, "raw", "environmental", "avgpm25_monthly.csv"),
  col_select = -1
)

pm2p5

# New PM2.5 data for Siha (without considering National Park area)
pm2p5_siha <- read_csv(
  file.path(data_path, "raw", "environmental", "avg_pm25_monthly_siha_np.csv"),
  col_select = -1
)

pm2p5_siha

# Substitute Siha observations in main pm2p5 dataframe
# New PM2.5 data for Siha (without considering National Park area)
pm2p5_siha <- pm2p5_siha |> 
  mutate(
    District = case_when(
      .default = District,
      District == "Siha_without_nationalpark" ~ "Siha"
    )
  )

pm2p5 <- pm2p5 |> 
  left_join(pm2p5_siha, by=c("District", "year", "month")) |> 
  mutate(
    avg_pm2.5_monthly = if_else(
      District == "Siha",
      avg_pm2.5_sihanp_monthly,
      avg_pm2.5_monthly
    )
  ) |> 
  select(- avg_pm2.5_sihanp_monthly)


# Regular formatting
pm2p5 <- pm2p5 |> 
  mutate(
    time = ym(paste0(year, month))
  ) |>
  select(- c(year, month)) |> 
  rename(
    district=District,
    pm2p5=avg_pm2.5_monthly
  ) |> 
  relocate(time)

pm2p5
```

### Greenness

```{r}
green <- read_csv(
  file.path(data_path, "raw", "environmental", "monthwise_greenness.csv")
)

green

green <- green |> 
  pivot_longer(
    cols = 2:last_col(),
    names_to = c("district", "month"),
    values_to = "greenness",
    names_sep = "_"
  )

green <- green |> 
  mutate(
    time = ym(paste0(year, month))
  ) |> 
  select( - c(year, month)) |> 
  mutate(
    district = recode(district,
                      moshi = "Moshi",
                      siha = "Siha")
  ) |> 
  relocate(time)

green
```

### Rain

Total rainfall (mm) and No. rain days.

```{r}
rain <- read_csv(
  file.path(data_path, "raw", "environmental", "rc_month_rain_satellite.csv"),
  col_select = -1
)

rain

rain <- rain |> 
  mutate(
    time = ym(paste0(year, month))
  ) |> 
  select( - c(year, month)) |> 
  relocate(time) |> 
  rename(total_rainfall = "Monthly Total Rainfall",
         n_raindays = "Number of Raindays")

rain
```

### Temperature

Minimum, mean and maximum temperatures.

```{r}
temp <- read_csv(
  file.path(data_path, "raw", "environmental", "sat_temp.csv"),
  col_select = -1
)

temp

temp <- temp |> 
  mutate(
    time = ym(paste0(year, month))
  ) |> 
  select( - c(year, month)) |> 
  relocate(time, district)

temp <- temp |> 
  pivot_wider(
    names_from=variable,
    values_from=value
  ) |> 
  rename(
    temp_mean = "Monthly mean temperature",
    temp_min = "Monthly mean minimum temperature",
    temp_max = "Monthly mean maximum temperature"
  ) |> 
  relocate(time, district, temp_mean, temp_min, temp_max)

temp
```

### Merge

```{r}
df_environ <- pm2p5 |>
  full_join(green, by=c("time", "district")) |> 
  full_join(rain, by=c("time", "district")) |> 
  full_join(temp, by=c("time", "district"))

df_environ <- df_environ |> 
  arrange(district, time)

# Add yearly population
df_environ <- df_environ |> 
  mutate(year = year(time)) |> 
  left_join(pop, by=c("district", "year")) |> 
  select(- year) |> 
  relocate(time, district, population)

df_environ |> 
  print(width=Inf)
```

### Missing data

Visualize the missing data.

```{r}

var_order <- colnames(df_environ)[3:10]

df_environ |>
  pivot_longer(
    cols = population:temp_max,
    names_to="variable",
    values_to="value"
  ) |> 
  mutate(
    variable = factor(variable, levels=var_order)
  ) |> 
  ggplot() +
  geom_tile(
    aes(x=time, y=variable, fill=is.na(value)),
    color="black",
    width=31
  ) +
  scale_fill_manual(
    values = c("steelblue3", "gray20"),
    labels = c("No", "Yes")
  ) +
  labs(
    fill = "Missing",
    x = "Month",
    y = ""
  ) +
  facet_wrap(
    ~ district,
    ncol=2
  ) +
  theme(
    legend.title = element_text(face="bold"),
    axis.title = element_text(face="bold"),
    strip.text = element_text(face="bold")
  )

```


The real important range is 2014-2022, which is where we have the disease data. Greenness has some missing values in-between years, which is a problem. We can use the rest of the variables from 2014 to 2020, so we would be losing 2 years of information. Rain is missing for Siha in 2021; if we had it, we would have all environmental variables of 2021 for the regression. The only environmental variable available for 2022 is PM2.5.

We might be able to impute the Greenness values with some criterion. We should ask Netra.



### Other air quality variables

There is data on other air quality variables from 2018 onward, but I do not understand the format (what is value.ID? Why does one place and time have multiple measurements?).

This data is NO2, O3, SO2 and AOD

```{r}
# Additional air quality variables (2018-) -----------------------------------------------

# NO2

no2 <- read_csv(
  file.path(data_path, "raw", "environmental", "no2_monthly_2018_2021.csv"),
  col_select = -1
)

no2

# O3
# file.path(data_path, "raw", "environmental", "ozone_monthly_2018_2021.csv")

# SO2
# file.path(data_path, "raw", "environmental", "so2_monthly_2018_2021.csv")

# AOD
# file.path(data_path, "raw", "environmental", "AOD_monthly_2018_2021.csv")

```


## Disease data

### Moshi

```{r}
# Moshi

moshi <- read_csv(
  file.path(data_path, "raw", "disease_v2", "Moshi_monthlydata_cleaned_june_2024.csv"),
  col_select = -1
)

moshi |> 
  print(width = Inf)

moshi <- moshi |> 
  pivot_longer(
    cols = Jan:Dec,
    names_to = "month",
    values_to = "n_cases"
  ) 

moshi

moshi <- moshi |> 
  mutate(
    time = ym(paste0(Year, month))
  ) |> 
  select(- c(Year, month)) |> 
  mutate(
    district = "Moshi"
  ) |> 
  rename(
    disease = Diseases,
    disease_group = Subcategory,
    disease_communicable = Category
  ) |> 
  relocate(time, district, n_cases, disease, disease_group, disease_communicable)
  
moshi
```

### Siha

```{r}
# Siha

siha <- read_csv(
  file.path(data_path, "raw", "disease_v2", "Siha_monthlydata_cleaned_june_2024.csv"),
  col_select = -1
)

siha |> 
  print(width = Inf)

siha <- siha |> 
  pivot_longer(
    cols = Jan:Dec,
    names_to = "month",
    values_to = "n_cases"
  ) 

siha

siha <- siha |> 
  mutate(
    time = ym(paste0(Year, month))
  ) |> 
  select(- c(Year, month, District)) |> 
  mutate(
    district = "Siha"
  ) |> 
  rename(
    disease = Diseases,
    disease_group = Subcategory,
    disease_communicable = Category
  ) |> 
  relocate(time, district, n_cases, disease, disease_group, disease_communicable)
  
siha
```


### Merge

```{r}
df_disease <- full_join(moshi, siha, by=colnames(moshi))

df_disease <- df_disease |> 
  arrange(district, disease, time)

df_disease
```


```{r}
df_disease$disease |> table()
```

Diseases differ in the number of observations. Snake And Insect Bites.

```{r}
df_disease$disease_group |> table()

df_disease$disease_communicable |> table()
```


```{r}
# Fix category
df_disease <- df_disease |> 
  mutate(
    disease = case_when(
      .default = disease,
      disease == "Snake And Insect Bites" ~ "Snake and Insect Bites"
    )
  )
```


### Missings

Explore missingness.

```{r}
#| fig-width: 20


df_disease |>
  mutate(
    disease_group = recode(
      disease_group,
      `Diarrheal disease/Gastrointesntinal infections`="Diarrheal disease/\nGastrointesntinal infections",
      `Other Communicable Diseases/Gastrointestinal infections`="Other Communicable Diseases/\nGastrointestinal infections"
      )
  ) |> 
  ggplot() +
  geom_tile(
    aes(x=time, y=disease, fill=is.na(n_cases)),
    color="black",
    width=31
  ) +
  scale_fill_manual(
    values = c("steelblue3", "gray20"),
    labels = c("No", "Yes")
  ) +
  labs(
    fill = "Missing",
    x = "Month",
    y = ""
  ) +
  facet_grid(
    cols = vars(district),
    rows = vars(disease_group),
    scales = "free_y",
    space = "free_y"
  ) +
  theme(
    legend.title = element_text(face="bold"),
    axis.title = element_text(face="bold"),
    strip.text = element_text(face="bold"),
    strip.background = element_blank(),
    strip.text.y = element_text(angle=0, size=rel(1)),
    strip.text.x = element_text(angle=0, size=rel(1.5))
  )

```

There are several diseases with complete observations. The dark squares indicate missing observations recorded as 'NA' in the tables. Blanks represent observations which were not present in the tables.

```{r}
#| fig-width: 20

# Case rate

df_disease |>
  mutate(
    disease_group = recode(
      disease_group,
      `Diarrheal disease/Gastrointesntinal infections`="Diarrheal disease/\nGastrointesntinal infections",
      `Other Communicable Diseases/Gastrointestinal infections`="Other Communicable Diseases/\nGastrointestinal infections"
      )
  ) |>
  left_join(
    select(df_environ, time, district, population),
    by = c("time", "district")
  ) |> 
  mutate(
    case_rate = n_cases / population
  ) |> 
  # pull(case_rate) |>
  # classInt::classIntervals(n=8, style="quantile") |> 
  # plot(pal=viridis::viridis_pal()(10))
  ggplot() +
  geom_tile(
    aes(x=time, y=disease, fill=case_rate*1e5),
    color="black",
    width=31
  ) +
  facet_grid(
    cols = vars(district),
    rows = vars(disease_group),
    scales = "free_y",
    space = "free_y"
  ) +
  scale_fill_viridis_c(
    transform = "log1p",
    breaks = c(0,10,100,1000,6000),
  ) +
  # scale_fill_gradientn(
  #   colours = RColorBrewer::brewer.pal(9, "Greens"),
  #   transform = "log1p",
  #   breaks = c(0,10,100,1000,6000)
  # ) +
  guides(
    fill = guide_colorbar(
      barheight = 46,
      title.vjust = 2,
    )
  ) +
  labs(
    fill = "Incidence rate\n(per 100k people)",
    x = "Month",
    y = ""
  ) +
  theme(
    legend.title = element_text(face="bold"),
    axis.title = element_text(face="bold"),
    strip.text = element_text(face="bold"),
    strip.background = element_blank(),
    strip.text.y = element_text(angle=0, size=rel(1)),
    strip.text.x = element_text(angle=0, size=rel(1.5)),
    legend.text = element_text(face="bold", size=rel(1.0))
  )
```



```{r}
#| fig-width: 20

# Case rate

df_disease |>
  mutate(
    disease_group = recode(
      disease_group,
      `Diarrheal disease/Gastrointesntinal infections`="Diarrheal disease/\nGastrointesntinal infections",
      `Other Communicable Diseases/Gastrointestinal infections`="Other Communicable Diseases/\nGastrointestinal infections"
      )
  ) |>
  left_join(
    select(df_environ, time, district, population),
    by = c("time", "district")
  ) |> 
  mutate(
    case_rate = n_cases / population
  ) |> 
  # pull(case_rate) |>
  # classInt::classIntervals(n=8, style="quantile") |> 
  # plot(pal=viridis::viridis_pal()(10))
  ggplot() +
  geom_tile(
    aes(x=time, y=disease, fill=case_rate*1e5),
    color="black",
    width=31
  ) +
  facet_grid(
    cols = vars(district),
    rows = vars(disease_group),
    scales = "free_y",
    space = "free_y"
  ) +
  # ) +
  scale_fill_viridis_b(
    # transform = "log1p",
    breaks = c(0,1,10,100,1000,6000)
  ) +
  guides(
    fill = guide_colorsteps(
      even.steps = TRUE,
      barheight = 46,
      title.vjust = 2,
    )
  ) +
  labs(
    fill = "Incidence rate\n(per 100k people)",
    x = "Month",
    y = ""
  ) +
  theme(
    legend.title = element_text(face="bold"),
    axis.title = element_text(face="bold"),
    strip.text = element_text(face="bold"),
    strip.background = element_blank(),
    strip.text.y = element_text(angle=0, size=rel(1)),
    strip.text.x = element_text(angle=0, size=rel(1.5)),
    legend.text = element_text(face="bold", size=rel(1.0))
  )
```

Repeat the figure grouping infectious diseases and non-communicable. Remove other vector-borne diseases (too many missings).


```{r}
#| fig-width: 20

# Case rate

df_disease |>
  mutate(
    disease_group = recode(
      disease_group,
      `Diarrheal disease/Gastrointesntinal infections`="Diarrheal disease/\nGastrointesntinal infections",
      `Other Communicable Diseases/Gastrointestinal infections`="Other Communicable Diseases/\nGastrointestinal infections"
      )
  ) |>
  # Remove disease category with many missings
  filter(disease_group != "Other vector borne diseases") |> 
  left_join(
    select(df_environ, time, district, population),
    by = c("time", "district")
  ) |> 
  mutate(
    case_rate = n_cases / population
  ) |> 
  ggplot() +
  geom_tile(
    aes(x=time, y=disease, fill=case_rate*1e5),
    color="black",
    width=31
  ) +
  facet_nested(
    cols = vars(district),
    rows = vars(disease_communicable, disease_group),
    scales = "free_y",
    space = "free_y",
    # strip = strip_vanilla(size = "variable", clip = "off"),
    strip = strip_nested(size = "variable", clip="off", bleed = FALSE),
    solo_line = TRUE,
    nest_line = TRUE,
    # switch = "y"
  ) +
  scale_fill_viridis_c(
    transform = "log1p",
    breaks = c(0,10,100,1000,6000),
  ) +
  guides(
    fill = guide_colorbar(
      barheight = 46,
      title.vjust = 2,
    )
  ) +
  labs(
    fill = "Incidence rate\n(per 100k people)",
    x = "Month",
    y = ""
  ) +
  theme(
    legend.title = element_text(face="bold"),
    axis.title = element_text(face="bold"),
    strip.text = element_text(face="bold"),
    strip.background = element_blank(),
    # ggh4x.facet.nestline = element_line(colour = "black"),
    strip.text.y = element_text(angle=0, size=rel(1)),
    strip.text.x = element_text(angle=0, size=rel(1.5)),
    legend.text = element_text(face="bold", size=rel(1.0))
  )

```


Save separate dataframes.

```{r}
saveRDS(
  df_environ,
  file.path(data_path, "processed", "environmental-variables_moshi-siha.Rds")
)

saveRDS(
  df_disease,
  file.path(data_path, "processed", "disease-cases_moshi-siha.Rds")
)
```

As the data is not too large, we will merge the environmental variables and the disease cases.

```{r}

data <- full_join(df_disease, df_environ, by=c("district", "time"))


# Prepare variables
data <- data |> 
  mutate(
    # Case_rate for plotting
    case_rate = n_cases / population,
  ) |> 
  arrange(district, time)

data |> print(width=Inf)
```



# Exploratory analysis

## Environmental data

We will fit a model to describe the temporal trend and seasonal component of each variable.

The environmental data is available at different temporal windows, so it is important to filter the dataframe for the not missing values of each respective variable.

```{r}
#| eval: false

# PM2.5

df_tmp <- df_environ |> 
  filter(! is.na(pm2p5)) |> 
  # Define month index and time index
  mutate(
    month_ind = month(time),
    time_ind = (year(time) - min(year(time)))*12 + month(time)
    # year_ind = year(time) - min(year(time)) + 1,
  )

  
df_tmp |> 
  ggplot() +
  geom_line(
    aes(x=time, y=pm2p5, color=district), linewidth=1
  ) +
  scale_x_date(date_breaks="year", date_labels = "%Y") +
  geom_vline(xintercept = unique(floor_date(df_tmp$time, "year")),
             color="gray70", linetype=2, linewidth=1)

# form <- 

library(mgcv)
library(gratia)


library(modelsummary)
library(marginaleffects)
library(patchwork)

dat <- filter(df_tmp, district=="Moshi")

mod <- gam(pm2p5 ~ te(month_ind, time_ind, bs=c("cc", "tp")), data=dat)

mod |> draw()

summary(mod)


plot_predictions(mod, condition="time_ind", type="response")
plot_predictions(mod, condition=c("time_ind", "month_ind"), type="response")


predictions(mod)

mod$model$month_ind |> unique()

# pred <- predict(mod, type="response")

pred <- predictions(mod, type="response") |> pull(estimate)

pred_trend <- predictions(
  mod,
  newdata = datagrid(model=mod,
                     time_ind=unique,
                     # month_ind=0
                     month_ind=6.5
                     )
) |> 
  pull(estimate)

pred_season <- pred - pred_trend

dat <- data.frame(
  mod$model,
  pred,
  pred_trend,
  pred_season,
  resid = mod$residuals
)

dat |> colnames()

dat |> 
  pivot_longer(
    cols = c(pm2p5, pred_trend, pred_season, resid),
    values_to = "y",
    names_to = "y_name"
  ) |> 
  mutate(
    y_name = factor(y_name, levels=c("pm2p5", "pred_trend", "pred_season", "resid"))
  ) |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=y)
  ) +
  facet_grid(
    "y_name ~ .",
    # switch = "y",
    scales = "free_y"
    
  )

p1 <- dat |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=pm2p5)
  ) +
  geom_line(
    aes(x=time_ind, y=pred), linetype=2
  ) +
  labs(
    # title="data + predicted",
    x=""
    )
p1

p2 <- dat |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=pred_trend)
  ) +
  labs(
    # title="trend",
    x=""
    )

p3 <- dat |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=pred_season)
  ) +
  labs(
    # title="seasonality",
    x=""
    )

p4 <- dat |> 
  ggplot() +
  geom_hline(
    yintercept = 0, linetype=2
  ) +
  geom_line(
    aes(x=time_ind, y=resid)
  ) +
  # geom_segment(
  #   aes(x=time_ind, xend=time_ind, y=0, yend=resid)
  # ) +
  geom_rect(
    data=barpos["resid", ],
    aes(
      xmin = left, xmax = right, ymax = top, ymin = bottom, group = y_name
    ),
    fill = "gray75", colour = "black", size = 1 / 3
  ) +
  labs(
    # title="residual"
    )
p4

xranges <- range(dat$time_ind)
barwidth <- (1 / 64) * diff(xranges)

yranges <- sapply(dat, range)[, c("pm2p5", "pred_trend", "pred_season", "resid")]
barlength <- yranges |> 
  apply(2, diff) |> 
  min()

barmid <- apply(yranges, 2, mean)

barpos <- data.frame(
        left = xranges[2] + barwidth, right = xranges[2] + barwidth * 2,
        top = barmid + barlength / 2, bottom = barmid - barlength / 2,
        time_ind = xranges[2],
        y = barmid,
        y_name = factor(colnames(yranges))
      )

      yranges <- vapply(split(data$y, data$parts), function(x) range(x, na.rm = TRUE), numeric(2))
      xranges <- range(data$datetime)
      barmid <- apply(yranges, 2, mean)
      barlength <- min(apply(yranges, 2, diff))
      barwidth <- (1 / 64) * diff(xranges)
      barpos <- data.frame(
        left = xranges[2] + barwidth, right = xranges[2] + barwidth * 2,
        top = barmid + barlength / 2, bottom = barmid - barlength / 2,
        parts = factor(colnames(yranges), levels = cn),
        datetime = xranges[2], y = barmid
      )
      p <- p + ggplot2::geom_rect(
        ggplot2::aes(
          xmin = .data[["left"]], xmax = .data[["right"]],
          ymax = .data[["top"]], ymin = .data[["bottom"]]
        ), data = barpos, fill = "gray75", colour = "black", size = 1 / 3)



p1 + p2 + p3 + p4 +
  plot_layout(ncol=1)


dat |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=pm2p5), color="yellow"
  ) +
  geom_line(
    aes(x=time_ind, y=pred), linetype=3
  ) +
  geom_line(
    aes(x=time_ind, y=pred_trend), linetype=2
  ) +
  geom_line(
    aes(x=time_ind, y=pred_season), linetype=2
  ) +
  geom_line(
    aes(x=time_ind, y=resid)
  ) +
  geom_line(
    aes(x=time_ind, y=pred_trend + pred_season + resid), color="purple"
  )
  

predictions(
  mod,
  newdata = datagrid(model=mod,
                     time_ind=unique,
                     month_ind=0
                     )
) |>
  # glimpse()
  ggplot() +
  geom_line(
    aes(x=time_ind, y=estimate)
  ) +
  geom_ribbon(
    aes(x=time_ind, ymin=conf.low, ymax=conf.high), alpha=0.2
  )

with_season <- predict(mod, type = 'response')

plot(with_season)
agg_over_season <- predictions(mod, 
                           newdata = datagrid(model = mod,
                                              time_ind = unique),
                           summary = FALSE,
                           type = 'response')
season_preds <- with_season - agg_over_season
p2 <- ggplot(airdat$data_train %>%
               dplyr::mutate(pred = apply(season_preds, 2, mean),
                             upper = apply(season_preds, 2, function(x) 
                               quantile(x, probs = 0.975)),
                             lower = apply(season_preds, 2, function(x) 
                               quantile(x, probs = 0.025))),
             aes(x = time, y = pred)) +
  geom_ribbon(aes(ymax = upper,
                  ymin = lower),
              alpha = 0.2) +
  geom_line()+
  labs(y = 'Expected passengers',
       title = 'Time-varying seasonality')



pred <- predict(mod, dat, type="terms", se.fit = TRUE)
pred2 <- predict(mod, dat, type="response", se.fit = TRUE)


dat <- transform(dat,
          trend = pred$fit[,"te(month_ind,time_ind)"],
          resid = mod$residuals,
          fitted = pred2$fit
          )

dat |> 
  ggplot() +
  geom_line(
    aes(x=time, y=trend)
  ) +
  geom_line(
    aes(x=time, y=pm2p5)
  )

dat |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=(seasonal + attr(pred, "constant")) |> exp()*1e5), color="blue"
  ) +
  geom_line(
    aes(x=time_ind, y=(trend + attr(pred, "constant")) |> exp()*1e5)
  ) +
  geom_line(
    aes(x=time_ind, y=(resid + attr(pred, "constant")) |> exp()*1e5), color="red"
  ) +
  geom_line(
    aes(x=time_ind, y = exp(seasonal+trend+resid + attr(pred, "constant"))*1e5), color="green"
  ) +
  geom_line(
    aes(x=time_ind, y=fitted*1e5), color="yellow"
  ) +
  geom_line(
    aes(x=time_ind, y=n_cases/population*1e5), color="orange"
  ) +
  geom_line(
    aes(x=time_ind, y = exp(seasonal+trend + attr(pred, "constant"))*1e5), color="purple"
  )








gam(pm2p5 ~ s(month_ind, bs="cc") + s(time_ind, bs="bs"), data=filter(df_tmp, district=="Moshi")) |> draw()

# gam(pm2p5 ~ s(month_ind, bs="cc") + s(time_ind, bs="bs"), data=filter(df_tmp, district=="Siha")) |> draw()

# gam(pm2p5 ~ s(month_ind, bs="cc") + s(time_ind, bs="bs"), data=filter(df_tmp, district=="Siha")) |> appraise()

# gamm(pm2p5 ~ s(month_ind, k=12, bs="cc") + s(year_ind, k=10), data=filter(df_tmp, district=="Moshi"))

# df_tmp$time |> as.numeric()
```


```{r}
#| eval: false

df_disease$disease |> table()

"Bronchial Asthma"


# data |> 
#   filter(disease == "Bronchial Asthma")

df_analysis <- df_disease |> 
  # Filter disease
  filter(disease == "Bronchial Asthma") |> 
  # Add explanatory variables
  left_join(df_environ, by=c("time", "district")) |> 
  # Prepare variables for time
  mutate(
    month_ind = month(time),
    time_ind = (year(time) - min(year(time)))*12 + month(time)
  )

df_analysis |> 
  print(width=Inf, n=13)

df_analysis_moshi <- df_analysis |> 
  filter(district == "Moshi")

df_analysis_siha <- df_analysis |> 
  filter(district == "Siha")


df_analysis |> 
  ggplot() +
  geom_line(
    aes(x=time, y=n_cases/population*1e5, color=district), linewidth=1
  ) +
  scale_x_date(date_breaks="year", date_labels = "%Y") +
  geom_vline(xintercept = unique(floor_date(df_analysis$time, "year")),
             color="gray70", linetype=2, linewidth=1)

df_analysis |> 
  ggplot() +
  geom_line(
    aes(x=time, y=n_cases, color=district), linewidth=1
  ) +
  scale_x_date(date_breaks="year", date_labels = "%Y") +
  geom_vline(xintercept = unique(floor_date(df_analysis$time, "year")),
             color="gray70", linetype=2, linewidth=1)


df_analysis |> 
  ggplot() +
  geom_line(
    aes(x=time, y=n_cases/population, color=district), linewidth=1
  ) +
  scale_x_date(date_breaks="year", date_labels = "%Y") +
  geom_vline(xintercept = unique(floor_date(df_analysis$time, "year")),
             color="gray70", linetype=2, linewidth=1)



mod <- gam(
  n_cases ~ s(month_ind, bs="cc") + s(time_ind, bs="bs"),
  offset = log(population),
  family = nb(link="log"),
  data=df_analysis_moshi
)

summary(mod)

mod$residuals |> acf()

# Correlated residuals

mod <- gamm(
  n_cases ~ s(month_ind, bs="cc") + s(time_ind, bs="bs"),
  offset = log(population),
  # family = nb(link="log"),
  family = poisson(link="log"),
  data=df_analysis_moshi,
  correlation = corARMA(form= ~ 1|time_ind, p=1),
  # control = list(niterEM = 0, msVerbose = TRUE, optimMethod="L-BFGS-B")
)


mod |> draw()

mod$coefficients
mod$fitted.values
mod$linear.predictors |> exp()

mod$offset

mod$model

mod$smooth |> str()

dat <- filter(df_analysis, district=="Moshi")
# dat$population <- 1

pred <- predict(mod, dat, type="terms", se.fit = TRUE)
pred2 <- predict(mod, dat, type="response", se.fit = TRUE)

# attr(pred, "constant")

dat <- transform(dat,
          seasonal = pred$fit[,"s(month_ind)"],
          trend = pred$fit[, "s(time_ind)"],
          resid = mod$residuals,
          fitted = pred2$fit
          )

dat |> 
  ggplot() +
  geom_line(
    aes(x=time_ind, y=(seasonal + attr(pred, "constant")) |> exp()*1e5), color="blue"
  ) +
  geom_line(
    aes(x=time_ind, y=(trend + attr(pred, "constant")) |> exp()*1e5)
  ) +
  geom_line(
    aes(x=time_ind, y=(resid + attr(pred, "constant")) |> exp()*1e5), color="red"
  ) +
  geom_line(
    aes(x=time_ind, y = exp(seasonal+trend+resid + attr(pred, "constant"))*1e5), color="green"
  ) +
  geom_line(
    aes(x=time_ind, y=fitted*1e5), color="yellow"
  ) +
  geom_line(
    aes(x=time_ind, y=n_cases/population*1e5), color="orange"
  ) +
  geom_line(
    aes(x=time_ind, y = exp(seasonal+trend + attr(pred, "constant"))*1e5), color="purple"
  )
  


get_smooth(mod, "s(month_ind)")

```


```{r}
#| eval: false

multiscales::US_polling

multiscales::US_polling_cartogram

library(tidyverse)

colors <- scales::colour_ramp(
  colors = c(red = "#AC202F", purple = "#740280", blue = "#2265A3")
)((0:7)/7)


install.packages("pals")


colors <- pals::parula(8)
colors <- pals::viridis(8)
colors <- pals::magma(8)
colors <- pals::cividis(8)
colors <- paletteer::paletteer_c("scico::berlin", 8)
# colors <- sequential_hcl(8, "Red-Blue")
colors <- sequential_hcl(8, "plasma")
colors <- divergingx_hcl(8, "RdYlBu")
colors <- divergingx_hcl(8, "Roma")
colors <- diverging_hcl(8, "Blue-Red3")
colors <- divergingx_hcl(8, "RdBu")
colors <- pals::brewer.rdbu(12)
colors <- pals::coolwarm(8)


colors <- pals::gnuplot(8)
colors <- colorRampPalette(pals::brewer.rdbu(11))(8)
colors |> show_col()


pals::brewer.rdbu(11)[round(seq(1,11,length.out=8))] |> show_col()


diamonds |> 
  drop_na() |> 
  ggplot() +
  geom_point(
    aes(x=carat, y=depth, fill=multiscales::zip(price, table)), color="black", shape=23, size=5
  ) +
  bivariate_scale("fill",
    # pal_vsup_viridis(option="viridis", begin = 0, end = 1),
    # pal_vsup_carto(),
    pal_vsup(
      values = colors,
      max_desat = 1,
      pow_desat = 1,
      max_light = 0.8,
      pow_light = 1
      ),
    # pal_vsup(
    #   values = colors,
    #   max_desat = 1,
    #   pow_desat = 1,
    #   max_light = 0,
    #   pow_light = 1
    #   ),
    # name = c("Clinton lead", "uncertainty"),
    # limits = list(c(-40, 40), c(0, 1)),
    # breaks = list(c(-40, -20, 0, 20, 40), c(0, 0.25, 0.50, 0.75, 1.)),
    # labels = list(waiver(), scales::percent),
    guide = "colourfan",
    # guide = "colourbox"
  ) +
  theme(
    legend.key.size = grid::unit(0.8, "cm"),
    # legend.title.align = 0.5,
    # plot.margin = margin(5.5, 20, 5.5, 5.5)
  )

pal_vsup(
  colors,
  unc_levels = 4,
  max_light = 0.9,
  max_desat = 0,
  pow_light = 0.8,
  pow_desat = 1
)




```

